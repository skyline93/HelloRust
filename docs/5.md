## 五、基本概念

### 5.1、变量

变量使用`let`关键字定义，而且变量的定义必须赋予初始值。

#### 5.1.1、不可变性
查看[示例项目](../code/4/variables/)如下代码：
```rust
fn main() {
    let x = 5;                              // 1
    println!("The value of x is {}", x);

    x = 6;                                  // 2
    println!("The value of x is {}", x);
}
```

分析：
1. 变量使用关键字`let`定义；
2. 变量默认是不可变的，如上代码编译将报错，如下：
```bash
$ cargo check
    Checking variables v0.1.0 (/workspace/hellorust/code/4/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:5:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
...
5 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
```

💌***Tip:*** 变量被设计成不可变的原因有几个方面的原因：
* 有时候代码逻辑依赖一个不可变的值，一旦变量值发生变化，往往很难跟踪；尤其修改变量操作仅在某种特定条件下发生时；  
* 当使用一些重型的数据结构，使用可变性修改一个实例可能比赋值和返回一个新的实例效率要高。为什么❓❓赋值和修改的底层是什么区别；
* 当使用较为轻量的数据结构时，通过创建新变量可能会使代码更加易于理解；

#### 5.1.2、 可变性
上述示例代码修改如下，增加`mut`关键字使变量具有可变性，即可通过编译：
```rust
fn main() {
    let mut x = 5;                              // 变量前增加mut关键字使变量具有可变性
    println!("The value of x is {}", x);

    x = 6;
    println!("The value of x is {}", x);
}
```

#### 5.1.3、隐藏
如上述代码也可修改为如下，对不可变的变量x再次使用`let`关键字定义，称作第一个变量x被第二个变量x隐藏了，如下：
```rust
fn main() {
    let x = 5;
    println!("The value of x is {}", x);

    let x = 6;                               // 将x隐藏，x的值为6
    println!("The value of x is {}", x);
}
```

这样对变量执行完一系列操作后，变量x还保持自身的不可变性。**但是要注意，重复使用`let`关键字声明变量虽然变量名不变，得到的确是一个全新的变量，而且通过隐藏，可以改变该变量的类型**，如下：
```rust
let x = "abc";  // 变量x是字符串类型
let x = 1;       // 变量x变成了数值
```

**而具有可变性的变量是不允许改变数据类型的**，如下操作编译将失败：
```rust
let mut x = "abc";  // 变量x是字符串类型
x = 1;               // 变量x变成了数值
```

报错如下：
```bash
$ cargo run
   Compiling variables v0.1.0 (/workspace/hellorust/code/4/variables)
error[E0308]: mismatched types
  --> src/main.rs:27:9
   |
26 |     let mut x = "abc";  // 变量x是字符串类型
   |                 ----- expected due to this value
27 |     x = 1;               // 变量x变成了数值
   |         ^ expected `&str`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error
```

### 5.2、常量
使用`const`关键字定义一个常量
```rust
const MAX_POINTS: u32 = 100_000
```

🌈代码风格：
* 常量通常使用下划线分隔的全大写字母命名，如果是数值类型，数值使用下划线提高可读性；

💌***Tip:*** 常量和不可变变量虽然都无法被其他代码修改，但它们还是存在一些区别：
* 常量不仅默认不可变，而且总是不可变；
* 常量的定义使用`const`关键字定义，而且必须显示指定其数据类型；
* 常量可以声明在任何作用域中，包括全局作用域；
* 常量只能在常量表达式中使用，无法将运行时的值绑定到常量上。

### 5.3、数据类型

rust的数据类型包括**标量类型**和**复合类型**

#### 5.3.1、整数类型
整数类型包括无符号整数和有符号整数  
|长度|有符号|无符号|  
|---  |---  |---  |
|8-bit  |i8 |u8 |
|16-bit |i16|u16|
|32-bit |i32|u32|
|64-bit |i64|u64|
|arch   |isize|usize|

整数字面量中，除了Byte，其余所有字面量都可以使用类型后缀
|整数字面量|示例|  
|---|---|
|Decimal|98_222|  
|Hex|0xff|
|Octal|0o77|
|Binary|0b1111_0000|
|Byte(u8 only)| b'A'|

***Tip:***   
* isize和usize两种特殊的整数类型，长度取决于程序运行的目标平台。64位架构上就是64位，32位架构上就是32位。
* 整数字面量的默认推导类型是i32，在大部分情况下运算速度最快
* isize和usize主要用作某些集合的索引

### 5.3.2、浮点数类型
浮点数类型包括`f32`和`f64`两种，分别占用32位和64位空间，浮点数字面量默认推导位`f64`。
```rust
fn main() {
  let x = 2.0;      // f64
  let y: f32 = 3.0  // f32
}
```

### 5.3.3、数值运算
```rust
fn main() {
  let sum = 5 + 10;             // 加法
  let difference = 95.5 - 4.3;  // 减法
  let product = 4 * 50;         // 乘法
  let quotient = 56.7 / 32.2;   // 除法
  let remainder = 43 % 5;       // 取余
}
```

***Tip:*** 不同类型的数值不能运算

### 5.3.4、布尔类型
布尔类型只有两个可能的值`true`和`false`，它们只占用单个字节的空间

```rust
fn main() {
  let t = true;
  let f = false;

  let is_ok: bool = true;
}
```

### 5.3.5、字符类型
char类型占用4个字节，是一个`Unicode`值，可以表示比ASCII多得多的字符内容

```rust
fn main() {
  let c = 'z';
  let z = '😻';
}
```

### 5.3.6、元组类型
元组的元素可以为不同类型，长度是固定的

```rust
let t = (500, 6.4, 2, 'c');
println!("t: {}, {}, {}, {}", t.0, t.1, t.2, t.3);  // 使用点号访问索引下标

let t: (u32, f64, u8, char) = (500, 6.4, 2, 'c');
println!("t: {}, {}, {}, {}", t.0, t.1, t.2, t.3);

let (a, b, c, d) = t;       // 解构
println!("t: {}, {}, {}, {}", a, b, c, d);

// t.0 = 200;  // t是不可变的
// println!("t: {}, {}, {}, {}", t.0, t.1, t.2, t.3);

let mut x = (500, 6.4, 2, 'c');
println!("x: {}, {}, {}, {}", x.0, x.1, x.2, x.3);

x.0 = 200;
println!("x: {}, {}, {}, {}", x.0, x.1, x.2, x.3);

// x.3 = 5; // 不同类型不允许赋不同类型的值
// println!("x: {}, {}, {}, {}", x.0, x.1, x.2, x.3);
```

### 5.3.7、数组类型
数组中的每个元素必须是相同的类型，并且长度是固定的。（动态数组例外，它允许调整长度）

```rust
let a = [1, 2, 3, 4, 5];
println!("a: {}, {}, {}, {}, {}", a[0], a[1], a[2], a[3], a[4]); // 使用方括号访问索引下标

let a: [i32; 5] = [1, 2, 3, 4, 5];
println!("a: {}, {}, {}, {}, {}", a[0], a[1], a[2], a[3], a[4]);

let a = [3; 5];
println!("a: {}, {}, {}, {}, {}", a[0], a[1], a[2], a[3], a[4]);

let a = ['b'; 5];
println!("a: {}, {}, {}, {}, {}", a[0], a[1], a[2], a[3], a[4]);

let b = [1,2,3,4,5];
let index = 8;
let element = b[index]; // 这里索引越界了，但是cargo check时不会报错，在运行时才发生panic使程序崩溃
println!("element: {}", element);
```

------
☝️上一节：[四、猜字游戏](4.md)  
👇下一节：待更新


🤞[首页](../README.md)
